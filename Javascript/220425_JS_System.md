# JavaScript의 변수, 함수의 생성

## Goals

1. JS의 코드의 평가단계와 실행단계
1. Hoisting 개념
1. Scope, ScopeChaining
1. 변수 let, const, var
1. JS의 GC

---

### _JS의 코드의 평가단계와 실행단계_

_JS는 프로그램이 실행시키면서 다음 2단계를 거쳐서 실행한다._  
_코드의 변수들을 등록하고 환경을 구성하는 코드의 평가단계_  
_코드를 한줄 씩 읽고 실행하는 실행단계 두 가지 단계를 크게 정의해 보자_  
_이해의 도움이 되기 위해서는 메모리의 Stack, Heap의 구조를 알고가면 이해의 도움이 많이 된다_

1. 코드의 평가단계

   - 코드를 실행하면 CallStack에서 호출을 해서 변수 등록 단계를 거친다.
   - 전역적으로 사용 할 수 있는 global의 환경을 만든다.
   - 그 다음 기초적인 window의 환경을 만든다. 여기서 window는 browser의 사용하는 api 및 속성을 사용하는 객체 이다.
   - 전역 변수로 var를 메모리에 변수를 등록하고, heap 메모리에 등록하는 참조 형식의 function을 등록한다.
   - function(선언된 함수만), var은 선언의 객체만 생성된다.
     - 단, var은 function 안에서 있을 때는 function callStack에서 실행될 때, 서언된다.

1. 코드의 실행단계
   - 실행 단계에서는 한줄 씩 코드를 읽어가며 값을 할당한다.
   - 여기서 let, const를 코드에 범위에 맞게 코드를 읽으며 값을 할당한다.

---

### _Hoisting_

_Hoisting 이란?_  
_전자의 코드의 평가단계에서 값을 이미 할당 받아 최상위 범위로 올려 유호범위를 전역으로 사용할 수 있는 것을 hoisting이라고 한다._  
_대표적을 코드의 평가단계에서 값을 할당 받는 var, function이 hoisting 대상이다._

_Hoisting은 변수, 함수 순서대로 진행되며. 아래의 코드를 보고 이해하자_

```js
hoisting();
a = 30;

function hoisting() {
  //실행단계
}
var a = 20;
```

- 라인 순서대로 읽지만 이미 코드의 평가의 단계에서 값을 할당받아 에러 없이 사용할 수 있다.
- var a의 메모리 값은 이미 설정되어있고, 값을 할당 및 사용 할 수 있다.
- function과 var를 우선순위를 최상위로 올려 메모리 접근이 가능하다.

---

### Scope, Scope Chaining

Scope는 소스가 실행되는 범위를 {} 를 통해서 변수의 접근할 수 있는 범위를 말합니다.  
Scope는 코드의 중갈호를 만나면 새로운 코드의 평가와 실행 환경이 생긴다.  
Scope의 범위 안에서 변수를 정의하고 만약 필요한 변수가 없다면 상단 구성환경의 queue 메모리를 참조하여  
값을 찾는다.

_여기서 function은 callStack에 쌓여 환경을 구성하고 호출 할 때, 대상 환경을 참조하여 실행한다._  
_callStack에서 쌓인 function들이 단계 단계 상위의 값을 연속적으로 참조하는 것이 Scope chaining이다._  
_Scope에서 다음 Scope 쇠사슬 처럼 참조하고 참조하는 형식이다._

---

### 변수 let, const, var

_변수의 내용을 알아보자_

- let : 일반적으로 -global 환경에 구성되는 변수로, 실행단계에서 코드를 읽을 때 stack 메모리 쌓여 값을 할당 받는다.
- const : 상수로 값을 변경할 수 없고, let과 같은 시점에 코드를 실행을 하면서 값을 할당 받는다.
- var : 코드의 평가 단계에서 선언과 값을 할당 받으며 전역 변수처럼 사용한다.

_여기서 변수는 const > let > var 순서대로 사용 하는 것이 좋다. 변수의 관리 및 선언과 재생성에서 var는 관리 하기 어렵기 때문에 다음순서대로 사용한다_

변수의 생성 단계에서 일시직인 사각지대가 발생하는데 그것을 다음과 같이 말한다.  
다음의 예를 확인하자

```js
let a = 10;


function func(){
  console.log(a);
  let a = 20l
}

func();

```

- ReferenceError: a is not defined가 발생한다.
- function은 평가단계에서 메모리 할당이 되었다.
- func을 실행하면 console.log에서 에러가 발생한다. 이유는 ?

_이유 : function scope에 들어가면서 새로운 callStack에서 함수를 호출하고 변수를 등록하는 새로운 환경을 만든다._  
 _a는 새로운 환경에서 이름은 등록되었지만 아직 값이 할당하기 전 a를 사용하면서 에러가 발생한다._

_**이렇게 변수의 scope 범위에서 할당 받기 전에 변수를 사용하는 시점을 TDZ(Temporal Dead Zon) 일시적 사각지대라고 한다.**_

---

### JS의 GC(Garbage Collector)

_자! 그럼 이렇게 변수, 함수를 메모리에 올려놓고 사용하는데 어떻게 메모리가 정리 하는지 알아보자_  
_GC(Garbage Collector)란 프로그램에서 필요 없는 메모리를 정리해주는 역할을 하는 객체이다._  
_무슨 기준으로 메모리를 저장할까?_

- 기준 : 할당된 메모리와 호출하는 Call Stack에 연결 상태를 확인한다.
- 단계

1. Call Stack에 쌓여 있는 function들의 사용하는 Scope 범위의 환경과 링크를 확인하다.
1. 함수가 끝나면 해당 링크는 끊어진다.
1. 링크가 끊어지는 Scope 메모리를 Release 한다.
1. CallStack에서 해당 function을 삭제한다.

위와 같은 단계로 JS는 메모리 관리를 한다.

---
